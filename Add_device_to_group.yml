- name: Discover and group devices automatically
  hosts: fortimanager
  collections:
    - fortinet.fortimanager
  connection: httpapi
  vars:
    ansible_httpapi_use_ssl: true
    ansible_httpapi_validate_certs: false
    ansible_network_os: fortinet.fortimanager.fortimanager
    ansible_user: "admin"
    ansible_password: "admin"
    ansible_host: "192.168.10.6"
  tasks:
    # First discover all devices in FortiManager
    - name: Get list of all devices
      fortinet.fortimanager.fmgr_fact:
        facts:
          selector: "dvmdb_device"
          params:
            adom: "root"
            fields: ["name", "hostname", "ip", "vdom"]
      register: device_facts

    # Create groups if they don't exist
    - name: Ensure HUBs group exists
      fortinet.fortimanager.fmgr_dvmdb_group:
        adom: "root"
        state: "present"
        dvmdb_group:
          name: "HUBs"
          desc: "Group for all hub devices"

    - name: Ensure SPOKEs group exists
      fortinet.fortimanager.fmgr_dvmdb_group:
        adom: "root"
        state: "present"
        dvmdb_group:
          name: "SPOKEs"
          desc: "Group for all spoke devices"

    # Add devices to appropriate groups based on hostname
    - name: Process discovered devices
      block:
        - name: Determine group membership
          set_fact:
            target_group: >-
              {% if item.hostname is match('^hub', ignorecase=True) %}HUBs
              {% elif item.hostname is match('^spoke', ignorecase=True) %}spokes
              {% else %}UNGROUPED{% endif %}

        - name: Add device to group
          fortinet.fortimanager.fmgr_dvmdb_group_adddev:
            adom: "root"
            group: "{{ target_group }}"
            device:
              name: "{{ item.name }}"
              vdom: "{{ (item.vdom.0.name | default('root')) if item.vdom is defined else 'root' }}"
          when: target_group != 'UNGROUPED'
          ignore_errors: yes

      loop: "{{ device_facts.meta.response_data }}"
      when: 
        - device_facts.meta.response_data is defined
        - item.name is defined
      loop_control:
        label: "{{ item.name }}"